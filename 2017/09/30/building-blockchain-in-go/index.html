<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 用 Go 打造简化的区块链（1）基础原型 · 码农杂谈</title><meta name="description" content="用 Go 打造简化的区块链（1）基础原型 - 码农杂谈"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://thinkingpy.com/atom.xml" title="码农杂谈"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">码农杂谈</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>首页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><ul class="shortcut-icons"><a href="https://github.com/thinkingpy" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">用 Go 打造简化的区块链（1）基础原型</h1><div class="post-info">Sep 30, 2017</div><div class="post-content"><blockquote>
<p>昨天笑来老师推文《用 Go 打造区块链（1）基础原型》，看后就产生了自己读原文的想法。本着把用英语当做自己刚需的初衷，我决定读原文、译原文。这不仅能用英语，而且还能输出文字，最后还有老师的翻译进行比对，一举三得。这是“用 Go 打造简化的区块链”系列的第一篇，欢迎交流指正！</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>区块链是 21 世纪最具革命性的技术之一，正日臻成熟，潜力有待发掘。本质上，区块链只是一个分布式数据库，而它的独特性在于它不是私有的而是共有的，比如每个区块链使用者都有它的全部或部门副本。而且，区块链也让实现加密货币和智能合约成为可能。</p>
<p>在这个文章系列中，我们将用区块链技术打造一种简化的数字货币。</p>
<p>（30）</p>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>让我们从“区块”开始，“区块”在“区块链”中用来存储有价值的信息。比如比特币区块是用来存储交易信息的，任何一种加密货币的本质都是如此。除了交易信息，区块还包含一些技术信息，比如区块的版本号、时间戳以及上一个区块的哈希值。</p>
<p>在这篇文章中，我们并不打算按照区块链或比特币描述的那样来实现区块，而是要实现一个简化版。它仅包含必要的信息，他看起像是这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</div><div class="line">    Timestamp      <span class="keyword">int64</span></div><div class="line">    Data           []<span class="keyword">byte</span></div><div class="line">    PrevBlockHash  []<span class="keyword">byte</span></div><div class="line">    Hash           []<span class="keyword">byte</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Timestamp</code> 是当前的时间戳（当区块被创建时生成），<code>Data</code> 是区块中实际有价值的信息，<code>PrevBlockHash</code> 存储了前一个区块的哈希，<code>Hash</code> 则是当前区块的哈希。按照比特币的规格，<code>Timestamp</code>,<code>PrevBlockHash</code> 和 <code>Hash</code> 称为区块头部，是单独的数据结构，而交易（就是我们这里的 <code>Data</code> )也是单独的数据结构。所以为了简化处理，我们将他们合在了一起。</p>
<p>那么我该如何计算哈希呢？计算哈希的方式是区块链的重要特征，而且也是区块链的安全保证。计算哈希是一项有难度的计算操作，即使在快速的计算机上也需要花费一些时间（这也是人们购买强劲 GPU 来挖比特币的原因）。这是一种有意的架构设计，这种设计使得添加新的区块有一定难度，因此也能防止添加后的区块被篡改。我们会在将来的文章中讨论并实现这种机制。</p>
<p>现在，我们将仅考虑区块的字段，把他们拼接起来，并计算拼接组合的 SHA-256 的哈希值。让我们用 <code>SetHash</code> 方法实现它：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span> <span class="title">SetHash</span><span class="params">()</span></span> &#123;</div><div class="line">    timestamp := []<span class="keyword">byte</span>(strconv.FormatInt(b.Timestamp, <span class="number">10</span>))</div><div class="line">    headers := bytes.Join([][]<span class="keyword">byte</span>&#123;b.PrevBlockHash, b.Data, timestamp&#125;, []<span class="keyword">byte</span>&#123;&#125;)</div><div class="line">    hash :=sha256.Sum256(headers)</div><div class="line"></div><div class="line">    b.Hash = hash[:]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，根据 Golang 语言的规范，我们将实现一个方法来简化区块的创建：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(data <span class="keyword">string</span>, prevBlockHash []<span class="keyword">byte</span>)</span> *<span class="title">Block</span></span> &#123;</div><div class="line">    block := &amp;Block&#123;time.Now().Unix(), []<span class="keyword">byte</span>(data), prevBlockHash, []<span class="keyword">byte</span>&#123;&#125;&#125;</div><div class="line">    block.SetHash()</div><div class="line">    <span class="keyword">return</span> block</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，这就是区块！</p>
<h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>现在，让我们来实现区块链。本质上，区块链就是具备某种结构的数据库：一个有序的、方向链接列表。也就是它是按照插入的顺序来存储的，并且每一个区块都链向它的前一个区块。这种结构支持从链上快速地获取最近的区块以及高效通过哈希获取区块。</p>
<p>在 Golang　中可以用　array 和 map 实现这种结构：array 可以存储有序哈希（在 Go 中 array 是有序的），map  可以存储 hash-&gt;block 对（map 是 无序的）。但是对于我们的区块链原型，我只用到 array ，因为现在我们还不需要用哈希去获取区块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Blockchain <span class="keyword">struct</span> &#123;</div><div class="line">    blocks []*Block</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是我们的第一个区块链，没想到居然这么简单！</p>
<p>现在，我们给它加上添加区块的功能：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *Blockchain)</span> <span class="title">AddBlock</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">    prevBlock := bc.blocks[<span class="built_in">len</span>(bc.blocks)<span class="number">-1</span>]</div><div class="line">    newBlock := NewBlock(data, prevBlock.Hash)</div><div class="line">    bc.blocks = <span class="built_in">append</span>(bc.blocks, newLBlock)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就是这样，还是？</p>
<p>要添加新的区块我们必须有一个已经存在的区块，但是我们的区块链中还没有任何区块。所有在任何区块链中都必须至少有一个区块，而这第一个区块就被称作创始区块。让我来实现一个创建这种区块的方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGenesisBlock</span><span class="params">()</span> *<span class="title">Block</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> NewBlock(<span class="string">"Genesis Block"</span>, []<span class="keyword">byte</span>&#123;&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们实现一个方法用创始区块来创建区块链：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlockchain</span><span class="params">()</span> *<span class="title">Blockchain</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> &amp;Blockchain&#123;[]*Block&#123;NewGenesisBlock()&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们来验证下区块链是否能运作正常：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    bc := NewBlockchain()</div><div class="line"></div><div class="line">    bc.AddBlock(<span class="string">"Send 1 BTC to Ivan"</span>)</div><div class="line">    bc.AddBlock(<span class="string">"Send 2 more BTC to Ivan"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> _, block := <span class="keyword">range</span> bc.blocks &#123;</div><div class="line">        fmt.Printf(<span class="string">"Prev. hash: %x\n"</span>, block.PrevBlockHash)</div><div class="line">        fmt.Printf(<span class="string">"Data: %s\n"</span>, block.Data)</div><div class="line">        fmt.Printf(<span class="string">"Hash: %x\n"</span>, block.Hash)</div><div class="line">        fmt.Println()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Prev. hash:</div><div class="line">Data: Genesis Block</div><div class="line">Hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168</div><div class="line"></div><div class="line">Prev. hash: aff955a50dc6cd2abfe81b8849eab15f99ed1dc333d38487024223b5fe0f1168</div><div class="line">Data: Send <span class="number">1</span> BTC to Ivan</div><div class="line">Hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1</div><div class="line"></div><div class="line">Prev. hash: d75ce22a840abb9b4e8fc3b60767c4ba3f46a0432d3ea15b71aef9fde6a314e1</div><div class="line">Data: Send <span class="number">2</span> more BTC to Ivan</div><div class="line">Hash: <span class="number">561237522</span>bb7fcfbccbc6fe0e98bbbde7427ffe01c6fb223f7562288ca2295d1</div></pre></td></tr></table></figure></p>
<p>就是这样！</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们建立了一个非常简单的区块链原型：它仅仅是一个车区块链数组，每一区块都与前一个区块相连，实际的区块链当然要复杂的多。我们的区块链添加新的区块简单快速，而实际的区块添加则需要做一些工作：获取的添加新区块的权限之前需要执行一些繁重的计算工作（这种机制称作工作量证明 Proof-of-Work)。而且区块链是分布式的数据库，没有单独的决策者。因此，新区块的加入须要被网络中的其他参与者确认和审核（这种机制称为共识）。目前我们的区块链中还没有交易呢！</p>
<p>接下来，我们要挨个谈谈它的每一个特征。</p>
<blockquote>
<p>原文：<a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-1/" target="_blank" rel="external">https://jeiwan.cc/posts/building-blockchain-in-go-part-1/</a></p>
</blockquote>
</div></article></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMTI1NS83ODA0"><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script><noscript>为正常使用来必力评论功能请激活JavaScript</noscript></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2017/09/23/writing is an important way of growing/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="http://thinkingpy.com">码农杂谈</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-106915528-1",'auto');ga('send','pageview');</script></body></html>